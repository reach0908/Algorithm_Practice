

#include <iostream>

using namespace std;
//N queen 문제
//NXN 크기의 체스판에 N개의 퀸을 서로 공격할 수 없도록 배치하는 문제
//퀸은 다음과 같이 이동할 수 있으므로 배치된 퀸 칸에 공격할 수 없는 위치로 배치해야함
// 퀸은 수직 수평 대각선 이동공격가능

//제약조건 : 퀸의 이동선상에 다른 퀸이 올라가있으면 안된다.
//상태공간트리로 체스판을 
// 가지치기 : 이동선상에 퀸이 있을 때
// 2차원배열로 체스판 좌표 생성


//퀸이 한줄에 두개가 들어갈 순 없다
// 다음줄에 가능한 경우는 4가지가 생긴다
//이를 트리 형태로 표현
// 구체적으로 자료구조를 트리형태로 구체화하지 않아도 된다(생각만 트리처럼 해도된다)

//DFS 방식으로 다음 것을 체크

//수직체크 : x좌표의 차가 0이면안된다.
//대각선체크 : x와 y좌표들끼리의 차의 절대값이 동일하면 안된다.
//hgjhgjh

int N;
int board[15];
int res = 0;

bool possible(int currentRow) {
	for (int i = 0; i < currentRow; i++)
	{
		if (board[i] == board[currentRow] || currentRow - i == abs(board[i] - board[currentRow])) {
			return false;
		}
	}
	cout << "찾았다!" << board[currentRow]<<endl;
	return true;
}

void DFS(int row) {
	if (row == N) {
		cout << "결과값 나옴" << endl;
		res++;
	}
	else
	{
		for (int col = 0; col < N; col++)
		{
			
			board[row] = col;
			
			if (possible(row))  // 갈 수 있는 길만 찾기 때문에, 프루닝을 할 필요는 없다. 프로미싱만?
			{
				cout << "Col and row =" << col << " " << row << endl;
				DFS(row + 1);
			}
		}
	}
	
}


int main()
{
	cin >> N;
	DFS(0);
	cout << res << endl;
	return 0;
}

//백트래킹
// 문제를 푸는 일종의 전략이다.
//백트래킹 또는 퇴각 검색
//제약 조건 만족 문제에서 해를 찾기 위한 전략
// - 해를 찾기 위해, 후보군에 제약 조건을 점진적으로 체크하다가, 해당 후보군이 만족할 수
//   없다고 판단되는 즉시, 백트랙, 다시는 이 후보군을 체크하지 않을 것을 표기하고
//   바로 다른 후보군으로 넘어가며, 결국 최적의 해를 찾는 방법
//실제 구현시, 고려할 수 있는 모든 경우의 수 후보군을 상태공간트리를 통해표현
// 각 후보군을 DFS 방식으로 확인
// 상태공간트리를 탐색하면서, 제약이 맞지 않으면 해의 후보가 될만한 곳으로 바로 넘어가서 탐색
//    - 프로미싱 : 해당 루트가 조건에 맞는지를 검사하는 기점
//    - 프루닝 : 가지치기 조건에 맞지 않으면 포기하고 다른 루트로 바로 돌아서서, 탐색의 시간을 절약하는 기법
// 즉 백트랙킹을 트리구조를 기반으로 DFS로 깊이 우선 탐색을 진행하면서 각 루트에 대해
// 조건에 부합하는지 체크(프로미싱) 만약 해당트리에서 조건에 부합하지 않는 노드는 더 이상
//DFS로 깊이 탐색을 진행하지 않고 가지를 처버린다. 프루닝as



//상태공간트리