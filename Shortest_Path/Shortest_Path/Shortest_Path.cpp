// Shortest_Path.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

#include <iostream>
#include <vector>
#include <algorithm>

//단일 출발 및 단일 도착 최단경로문제
// 단일출발 최단경로 문제
//	- 그래프 내의 특정노드u와 그래프 내 다른 모든 노드 각각의 가장 짧은 경로를 찾는 문제
//전체 쌍 최단 경로
//	- 그래프 내의 모든 노드 쌍에 대한 최단경로를 찾는 문제


//다익스트라 알고리즘
// 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며, 최단거리를 갱신하는 기법
// 다익스트라 알고리즘은 너비우선탐색과 유사
//	- 첫 정점부터 각 노드간의 거리를 저장하는 배열을 만든 후, 첫 정점의 인접노드 간의 거리부터 먼저 계산하면서, 
//	- 해당 노드간의 가장 짧은 거리를 해당배열에 업데이트
//			- 다익스트라 알고리즘의 다양한 변형 로직이 있지만, 가장 개선된 우선순위 큐를 사용하는 방식에
//			- 집중하여 설명함


//우선순위 큐를 활용한 다익스트라 알고리즘

// 우선순위 큐는 MiniHeap방식을 사용하여 현재 가장 짧은 거리를 가진 노드 정보를 먼저 꺼내게 됨
// 1. 첫 정점을 기준으로 배열을 선언하여 첫 정점에서 각 정점까지의 거리를 저장
// 초기에는 첫 정점의 거리는 0, 나머지는 무한대로 저장함(inf라고 표현함)
// 우선순위 큐에 첫 정점 거리0만 먼저 넣음

// 2. 우선순위 큐에서 노드를 꺼냄
// 첫 정점에 인접한 노드를 각각에 대해, 첫 정점에서 각 노드로 가는 거리와 현재 배열에 저장되어 있는 첫 정점에서 각 정점까지의 거리를 비교한다.
// 배열에 저장되어 있는 거리보다, 첫 정점에서 해당 노드로 가는 거리가 더 짧을 경우, 배열에 해당 노드의 거리를 업데이트한다.
// 배열에 해당 노드의 거리가 업데이트된 경우, 우선순위 큐에 넣는다.
// - 결과적으로 너비 우선탐색방식과 유사ㅓ하게, 첫 정점에 인접한 노드들을 순차적으로 방문하게 됨
// - 만약 배열 기록된 현재까지 발견된 가장 짧은 거리보다, 더 긴 거리(루트)를 가진 (노드,거리)의 경우에는 해당노드와 인접한 노드간의 거리 계산을 한다.

// 3. 2번의 과정을 우선순위 큐에 꺼낼 노드가 없을 때까지 반복한다.

using namespace std;

#define INF 987654321

int V, E, K; // 정점의 수, 간선의 수, 시작 정점 번호

vector<vector<int>> graph; // 간선 가중치, 그래프의 인접리스트

vector<int> dijkstra() {
	vector<int> s, d; // 방문여부, 최단경로

	s.assign(V, false); //assign 함수는 벡터안에 일정한 값으로 초기화해준다.
	d.assign(V, INF);
	d[K - 1] = 0; // 자기 자신까지의 거리는 0
	while (1)
	{
		int m = INF, N = -1;

		for (int j = 0; j < V; j++)
		{
			if (!s[j] && m > d[j]) {
				m = d[j];
				N = j;
			}

		}
		if (m == INF)
		{
			break; // m이 INF라는 이야기는 방문하지 않은 노드들의 d값이 전부 INF라는 뜻이다.
		}
		s[N] = true;
		for (int i = 0; i < V; i++)
		{
			if(s[i]) continue; //j번째 노드가 이미 방문되었다면, d[j]는 이미 결정된 최솟값이므로 변경하면 안된다.
			unsigned int via = d[N] + graph[N][i];
			if (d[i]>via)
			{
				d[i] = via; // 방문할노드에서 다른 방향 간선이 있는데 그게 더 작다면 그걸로 업데이트
			}
		}

	}
	return d;
}

int main() {
	cin >> V >> E >> K;
	graph.assign(V, vector<int>(V, INF));

	while (E--) // 간선의 개수를 채울때까지
	{
		int u, v, w;
		cin >> u >> v >> w;
		graph[u - 1][v - 1] = w;
	}
	vector<int> d = dijkstra();
	for (int i = 0; i < V; i++)
	{
		if (d[i] == INF) {
			cout << "INF" << endl;
		}
		else {
			cout << d[i] << endl;
		}
	}
	return 0;
}